global grip_detected = False
global lost_grip = False
thread lost_grip_thread():
  while (True):
    if True == get_digital_in(9):
      sync()
      sync()
      if True == grip_detected:
        if get_digital_in(8) == False:
          grip_detected = False
          lost_grip = True
        end   
      end
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
    end
    sync()
  end
end 
if Force_ > 40:
  Force_ = 40
  popup("'Force_' is too high - the value have been limited to  40N", title="Warning",  warning = True, error=False, blocking=True)
end
if Force_ < 3:
  Force_ = 3
  popup("'Force_' is too low - the value have been limited to  3N", title="Warning",  warning = True, error=False, blocking=True)
end
if Force2 > 40:
  Force2 = 40
  popup("'Force2' is too high - the value have been limited to  40N", title="Warning",  warning = True, error=False, blocking=True)
end
if Force2 < 3:
  Force2 = 3
  popup("'Force2' is too low - the value have been limited to  3N", title="Warning",  warning = True, error=False, blocking=True)
end
if Close > 110:
  Close = 110
  popup("'Close' is too high - the value have been limited to  110mm", title="Warning",  warning = True, error=False, blocking=True)
end
if Close < 0:
  Close = 0
  popup("'Close' is too low - the value have been limited to  0mm", title="Warning",  warning = True, error=False, blocking=True)
end  
if Open > 110:
  Open = 110
  popup("'Open' is too high - the value have been limited to  110mm", title="Warning",  warning = True, error=False, blocking=True)
end
if Open < 0:
  Open = 0
  popup("'Open' is too low - the value have been limited to  0mm", title="Warning",  warning = True, error=False, blocking=True)
end 
if Close2 > 110:
  Close2 = 110
  popup("'Close2' is too high - the value have been limited to  110mm", title="Warning",  warning = True, error=False, blocking=True)
end
if Close2 < 0:
  Close2 = 0
  popup("'Close2' is too low - the value have been limited to  0mm", title="Warning",  warning = True, error=False, blocking=True)
end
if Open2 > 110:
  Open2 = 110
  popup("'Open2' is too high - the value have been limited to  110mm", title="Warning",  warning = True, error=False, blocking=True)
end
if Open2 < 0:
  Open2 = 0
  popup("'Open2' is too low - the value have been limited to  0mm", title="Warning",  warning = True, error=False, blocking=True)
end
force0 = floor(Force2)
pos0 = floor(Close2*10)
force1 = floor(Force2)
pos1 = floor(Open2*10)
force2 = floor(Force_)
pos2 = floor(Close*10)
force3 = floor(Force_)
pos3 = floor(Open*10)  
def bit_bang_spi_master_UR_script(input):
  local i = 0
  while i < 8:
    set_digital_out(8, True)
  
    if input >= 128:
      set_digital_out(9, False) 
      input = input - 128
    else:
      set_digital_out(9, True) 
    end  
    input = input * 2
    sync()
    set_digital_out(8, False)
    sync() 
    i = i + 1
  end
end  
def on_wait(input):
  local sync_cnt = 0
  local sync_cnt_target = floor(input/0.008)
  while sync_cnt < sync_cnt_target:
    sync()
    sync_cnt = sync_cnt + 1
  end
end 
socket_open("127.0.0.1", 29999)
socket_send_string("popup Programming RG2, please wait...")
socket_send_byte(10)
version_number = 0 
length_ = 15         
set_tool_voltage(0)
on_wait(2.0)
set_digital_out(8, False) 
set_digital_out(9, False)
set_tool_voltage(24)
on_wait(0.032)
set_tool_voltage(0)
on_wait(0.064)

set_tool_voltage(24)
on_wait(0.032)
set_tool_voltage(0)
on_wait(0.064)
set_tool_voltage(24)
on_wait(0.032)
set_tool_voltage(0)
on_wait(0.064)
set_tool_voltage(24)
on_wait(0.032)
set_tool_voltage(0)
on_wait(0.064)
set_tool_voltage(24)
timeout = 0
while get_digital_in(8) == False:
  timeout = timeout+1
  sync()
  if timeout > 250:
    break
  end
end
if timeout < 250:
  timeout = 0
end
while get_digital_in(9):
  timeout = timeout+1
  sync()
  if timeout > 250:
    break
  end
end 
if timeout < 250:
  bit_bang_spi_master_UR_script(version_number)
  bit_bang_spi_master_UR_script(length_)
  bit_bang_spi_master_UR_script(force0)
  bit_bang_spi_master_UR_script(pos0 - (floor(pos0/256)*256))
  bit_bang_spi_master_UR_script(floor(pos0/256))
  bit_bang_spi_master_UR_script(force1)
  bit_bang_spi_master_UR_script(pos1 - (floor(pos1/256)*256))
  bit_bang_spi_master_UR_script(floor(pos1/256))
  bit_bang_spi_master_UR_script(force2)
  bit_bang_spi_master_UR_script(pos2 - (floor(pos2/256)*256))
  bit_bang_spi_master_UR_script(floor(pos2/256))
  bit_bang_spi_master_UR_script(force3)
  bit_bang_spi_master_UR_script(pos3 - (floor(pos3/256)*256))
  bit_bang_spi_master_UR_script(floor(pos3/256))
  bit_bang_spi_master_UR_script(84)
end 
socket_send_string("close popup")
socket_send_byte(10)
on_wait(0.056)
if timeout < 250:
  timeout = 0
end
while get_digital_in(9) == False:
  timeout = timeout+1
  sync()
  if timeout==2:
    set_digital_out(8, True)
  end
  if timeout > 250:
    popup("RG2 is not responding", title="Error",  warning = False, error=True,  blocking=True)
    break
  end
end
def open():
  if (get_digital_out(8) == False) and (get_digital_out(9) == False):
    popup("RG2 has already executed open()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  enter_critical
    set_digital_out(8, False)
    set_digital_out(9, False)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def close():
  if (get_digital_out(8) == True) and (get_digital_out(9) == False):
    popup("RG2 has already executed close()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  enter_critical
    set_digital_out(8, True)
    set_digital_out(9, False)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def open2():
  if (get_digital_out(8) == False) and (get_digital_out(9) == True):
    popup("RG2 has already executed open2()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  enter_critical
    set_digital_out(8, False)
    set_digital_out(9, True)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def close2():
  if (get_digital_out(8) == True) and (get_digital_out(9) == True):
    popup("RG2 has already executed close2()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  enter_critical
    set_digital_out(8, True)
    set_digital_out(9, True)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def open_master():
  if (get_digital_out(8) == False):
    popup("RG2 has already executed open_master()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  enter_critical
    set_digital_out(8, False)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def close_master():
  if (get_digital_out(8) == True):
    popup("RG2 has already executed close_master()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  enter_critical
    set_digital_out(8, True)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def open_slave():
  if (get_digital_out(9) == False):
    popup("RG2 has already executed open_slave()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  enter_critical
    set_digital_out(9, False)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def close_slave():
  if (get_digital_out(9) == True):
    popup("RG2 has already executed close_slave()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  enter_critical
    set_digital_out(9, True)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
LostGripThread = run lost_grip_thread()
socket_close()
