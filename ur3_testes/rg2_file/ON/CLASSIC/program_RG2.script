global grip_detected = False
global lost_grip = False
thread lost_grip_thread():
  while (True):
    if True == get_digital_in(9):
      sync()
      sync()
      if True == grip_detected:
        if get_digital_in(8) == False:
          grip_detected = False
          lost_grip = True
        end   
      end
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
    end
    sync()
  end
end 
if Force_ > 40:
  Force_ = 40
  popup("'Force_' is too high - the value have been limited to  40N", title="Warning",  warning = True, error=False, blocking=True)
end
if Force_ < 3:
  Force_ = 3
  popup("'Force_' is too low - the value have been limited to  3N", title="Warning",  warning = True, error=False, blocking=True)
end
if Force2 > 40:
  Force2 = 40
  popup("'Force2' is too high - the value have been limited to  40N", title="Warning",  warning = True, error=False, blocking=True)
end
if Force2 < 3:
  Force2 = 3
  popup("'Force2' is too low - the value have been limited to  3N", title="Warning",  warning = True, error=False, blocking=True)
end
if Close > 110:
  Close = 110
  popup("'Close' is too high - the value have been limited to  110mm", title="Warning",  warning = True, error=False, blocking=True)
end
if Close < 0:
  Close = 0
  popup("'Close' is too low - the value have been limited to  0mm", title="Warning",  warning = True, error=False, blocking=True)
end  
if Open > 110:
  Open = 110
  popup("'Open' is too high - the value have been limited to  110mm", title="Warning",  warning = True, error=False, blocking=True)
end
if Open < 0:
  Open = 0
  popup("'Open' is too low - the value have been limited to  0mm", title="Warning",  warning = True, error=False, blocking=True)
end 
if Close2 > 110:
  Close2 = 110
  popup("'Close2' is too high - the value have been limited to  110mm", title="Warning",  warning = True, error=False, blocking=True)
end
if Close2 < 0:
  Close2 = 0
  popup("'Close2' is too low - the value have been limited to  0mm", title="Warning",  warning = True, error=False, blocking=True)
end
if Open2 > 110:
  Open2 = 110
  popup("'Open2' is too high - the value have been limited to  110mm", title="Warning",  warning = True, error=False, blocking=True)
end
if Open2 < 0:
  Open2 = 0
  popup("'Open2' is too low - the value have been limited to  0mm", title="Warning",  warning = True, error=False, blocking=True)
end
force0 = floor(Force2)
pos0 = floor(Close2*10)
force1 = floor(Force2)
pos1 = floor(Open2*10)
force2 = floor(Force_)
pos2 = floor(Close*10)
force3 = floor(Force_)
pos3 = floor(Open*10)  
def bit_bang_spi_master_UR_script(input):
  local i = 0
  local output =0
  while i < 8:
    set_digital_out(8, True)
  
    if input >= 128:
      set_digital_out(9, False) 
      input = input - 128
    else:
      set_digital_out(9, True) 
    end  
    input = input * 2
    output = output*2
    if get_digital_in(8):
      output = output+1
    end
    sync()
    set_digital_out(8, False)
    sync() 
    i = i + 1
  end
  return output
end  
def on_wait(input):
  local sync_cnt = 0
  local sync_cnt_target = floor(input/0.008)
  while sync_cnt < sync_cnt_target:
    sync()
    sync_cnt = sync_cnt + 1
  end
end 
socket_open("127.0.0.1", 29999)
socket_send_string("popup Programming RG2, please wait...")
socket_send_byte(10)
version_number = 0 
length_ = 15         
set_tool_voltage(0)
on_wait(2.0)
set_digital_out(8, False) 
set_digital_out(9, False)
set_tool_voltage(24)
on_wait(0.032)
set_tool_voltage(0)
on_wait(0.064)

set_tool_voltage(24)
on_wait(0.032)
set_tool_voltage(0)
on_wait(0.064)
set_tool_voltage(24)
on_wait(0.032)
set_tool_voltage(0)
on_wait(0.064)
set_tool_voltage(24)
on_wait(0.032)
set_tool_voltage(0)
on_wait(0.064)
set_tool_voltage(24)
timeout = 0
while get_digital_in(8) == False:
  timeout = timeout+1
  sync()
  if timeout > 250:
    break
  end
end
if timeout < 250:
  timeout = 0
end
while get_digital_in(9):
  timeout = timeout+1
  sync()
  if timeout > 250:
    break
  end
end 
if timeout < 250:
  global xgo = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  xgo[0] = bit_bang_spi_master_UR_script(version_number)
  xgo[1] = bit_bang_spi_master_UR_script(length_)
  xgo[2] = bit_bang_spi_master_UR_script(force0)
  xgo[3] = bit_bang_spi_master_UR_script(pos0 - (floor(pos0/256)*256))
  xgo[4] = bit_bang_spi_master_UR_script(floor(pos0/256))
  xgo[5] = bit_bang_spi_master_UR_script(force1)
  xgo[6] = bit_bang_spi_master_UR_script(pos1 - (floor(pos1/256)*256))
  xgo[7] = bit_bang_spi_master_UR_script(floor(pos1/256))
  xgo[8] = bit_bang_spi_master_UR_script(force2)
  xgo[9] = bit_bang_spi_master_UR_script(pos2 - (floor(pos2/256)*256))
  xgo[10] = bit_bang_spi_master_UR_script(floor(pos2/256))
  xgo[11] = bit_bang_spi_master_UR_script(force3)
  xgo[12] = bit_bang_spi_master_UR_script(pos3 - (floor(pos3/256)*256))
  xgo[13] = bit_bang_spi_master_UR_script(floor(pos3/256))
  xgo[14] = bit_bang_spi_master_UR_script(84)
  sync()
  i = 0
  while i < 13:
    xgo[i] = xgo[i]*2+floor(xgo[i+1]/128)-floor(xgo[i]/128)*256
    i=i+1
  end
  sync()
  global xmsgstr=[97,100,100,84,111,76,111,103,32,82,71,50,32,70,87,32,88,46,88,46,88,32,40,88,88,88,32,88,88,32,88,88,88,88,41,32,115,47,110,32,82,71,50,88,88,88,88,88,88,88,32,40,88,88,88,32,88,88,32,88,88,88,88,41,32]
  FWVI=16
  FWDI=23
  SNI=43
  xmsgstr[FWVI+0]=48+xgo[0]-128
  xmsgstr[FWVI+2]=48+xgo[1]
  xmsgstr[FWVI+4]=48+xgo[2]
  if xgo[0]<128:
     xmsgstr[0]=0
  end
  month_str = [0,0,0]
  global xstr = [32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32]
  sync()
  def short_date_2_string(input_date):
    days = input_date-(floor(input_date/31)*31)
    month = (input_date-days)/31-(floor(input_date/(12*31))*(12))
    years = floor(input_date/(31*12))+2000
    if month == 0:    month_str = [74,97,110] end
    if month == 1:    month_str = [70,101,98] end
    if month == 2:    month_str = [77,97,114] end
    if month == 3:    month_str = [65,112,114] end
    if month == 4:    month_str = [77,97,121] end
    if month == 5:    month_str = [74,117,110] end
    if month == 6:    month_str = [74,117,108] end
    if month == 7:    month_str = [65,117,103] end
    if month == 8:    month_str = [83,101,112] end
    if month == 9:    month_str = [79,99,116] end
    if month == 10:   month_str = [78,111,118] end
    if month == 11:   month_str = [68,101,99] end
    xstr[0]=month_str[0]
    xstr[1]=month_str[1]
    xstr[2]=month_str[2] 
    days = days+1
    if days >= 10:
      xstr[4] =48+floor(days/10)
      xstr[5] =48+days-10*floor(days/10)
    else:
      xstr[5] =48+days
    end
    xstr[7] = 48+floor(years/1000)
    xstr[8] = 48+floor((years-floor(years/1000)*1000)/100)
    xstr[9] = 48+floor((years-floor(years/100)*100)/10)
    xstr[10] = 48+floor((years-floor(years/10)*10)/1)
    if years<2014:
      xstr[0]=0
    end
    return xstr
  end
  sync()
  dfw = (xgo[3]*256)+xgo[4]
  date_string = short_date_2_string(dfw)
  i=0
  sync()
  while i < 11:
    xmsgstr[FWDI+i]=date_string[i]
    i=i+1
  end
  if xmsgstr[FWDI]==0: xmsgstr[FWDI-1]=0 end
  sync()
  drg = (xgo[8]*256)+xgo[9]
  rg_date_string = short_date_2_string(drg)
  if xgo[5] != 0:
  xmsgstr[SNI-7] = 0
  end
  SN=10200+(xgo[6]*256)+xgo[7]
  if SN == 10200:
  xmsgstr[SNI-7] = 0
  end
  sync()
  xmsgstr[SNI]=48+floor(SN/10000) SN=SN-floor(SN/10000)*10000  xmsgstr[SNI+1]=48+floor(SN/1000) SN=SN-floor(SN/1000)*1000  xmsgstr[SNI+2]=48+floor(SN/100) SN=SN-floor(SN/100)*100  xmsgstr[SNI+3]=48+floor(SN/10) SN=SN-floor(SN/10)*10  xmsgstr[SNI+4]=48+floor(SN/1)  xmsgstr[SNI+5]=rg_date_string[9] xmsgstr[SNI+6]=rg_date_string[10]
  sync()
  SNDI=52
  i=0
  while i < 11:
    xmsgstr[SNDI+i]=rg_date_string[i]
    i=i+1
  end
  i=0
  while i < 65:
    if xmsgstr[i] != 0:
      socket_send_byte(xmsgstr[i])
      xmsgstr[i]=1
      if i%20==0:
        sync() 
      end
      i=i+1
    else:
      i=65
    end
  end
  socket_send_byte(10)
  sync()
  xgo = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
end 
socket_send_string("close popup")
socket_send_byte(10)
on_wait(0.056)
if timeout < 250:
  timeout = 0
end
while get_digital_in(9) == False:
  timeout = timeout+1
  sync()
  if timeout==2:
    set_digital_out(8, True)
  end
  if timeout > 250:
    popup("RG2 is not responding", title="Error",  warning = False, error=True,  blocking=True)
    break
  end
end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
def open():
  if (get_digital_out(8) == False) and (get_digital_out(9) == False):
    popup("RG2 has already executed open()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  global grip_detected = False
  enter_critical
    set_digital_out(8, False)
    set_digital_out(9, False)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def close():
  if (get_digital_out(8) == True) and (get_digital_out(9) == False):
    popup("RG2 has already executed close()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  global grip_detected = False
  enter_critical
    set_digital_out(8, True)
    set_digital_out(9, False)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def open2():
  if (get_digital_out(8) == False) and (get_digital_out(9) == True):
    popup("RG2 has already executed open2()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  global grip_detected = False
  enter_critical
    set_digital_out(8, False)
    set_digital_out(9, True)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def close2():
  if (get_digital_out(8) == True) and (get_digital_out(9) == True):
    popup("RG2 has already executed close2()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  global grip_detected = False
  enter_critical
    set_digital_out(8, True)
    set_digital_out(9, True)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def open_master():
  if (get_digital_out(8) == False):
    popup("RG2 has already executed open_master()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  global grip_detected = False
  enter_critical
    set_digital_out(8, False)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def close_master():
  if (get_digital_out(8) == True):
    popup("RG2 has already executed close_master()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  global grip_detected = False
  enter_critical
    set_digital_out(8, True)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def open_slave():
  if (get_digital_out(9) == False):
    popup("RG2 has already executed open_slave()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  global grip_detected = False
  enter_critical
    set_digital_out(9, False)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
def close_slave():
  if (get_digital_out(9) == True):
    popup("RG2 has already executed close_slave()", title="Notice",  warning = False, error = False, blocking=True)
  else:
  global grip_detected = False
  enter_critical
    set_digital_out(9, True)
  exit_critical
  timeout = 0
  while get_digital_in(9) == True:
    timeout = timeout+1
    sync()
    if timeout > 500:
      break
    end
  end

  timeout = 0
  while get_digital_in(9) == False:
    timeout = timeout+1
    sync()
    if timeout > 500:
      popup("RG2 is not responding", title="Error",  warning = False, error=True, blocking=True)
      break
    end
  end
  end
  global grip_detected = False
  global lost_grip = False
  if(True == get_digital_in(8)):
    grip_detected = True
  end
  set_analog_inputrange(2, 1)
  sync()
  sync()
  sync()
    global measure_width = (floor(((get_analog_in(2)-0.026)*110/2.976)*10))/10
  return grip_detected
end
LostGripThread = run lost_grip_thread()
socket_close()
#################################################
#  This scrips is used for the RG2 gripper and should not be modified
#################################################
####################  On Robot  #####################
#  URPs:    Description
#    RG2_Template.urp	Simple program for open and close RG2
#    RG2_SubP.urp	Sub program for adding RG2 to existing program
#    RG2_Dual.urp	Simple program for dual gripper operation

#  Scripts:   Function equivalent
#    open.script	open()
#    close.script	close()
#    open2.script	open2()
#    close2.script	close2()
#    program_RG2.script	-------------
# All open/close scripts is possible to single step. The functions return "grip_detected"

#  Variabels:	Input for	         Unit		    Unit 
#    Input:			Output:           
#      Open	open()	         [mm]	grip_detected	    (True/False)
#      Close	close()	         [mm]	lost_grip	    (True/False)
#      Force_	open()/close()            [N]	measure_width  [mm]
#      Open2	open2()	         [mm]	 
#      Close2	close2()	         [mm]	 
#      Force2	open2()/close2()        [N] 
